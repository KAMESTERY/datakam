// This file is generated by rust-protobuf 2.1.2. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct Content {
    // message fields
    pub documents: ::protobuf::RepeatedField<Document>,
    pub media_items: ::protobuf::RepeatedField<Media>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Content {
    pub fn new() -> Content {
        ::std::default::Default::default()
    }

    // repeated .contentkm.Document documents = 1;

    pub fn clear_documents(&mut self) {
        self.documents.clear();
    }

    // Param is passed by value, moved
    pub fn set_documents(&mut self, v: ::protobuf::RepeatedField<Document>) {
        self.documents = v;
    }

    // Mutable pointer to the field.
    pub fn mut_documents(&mut self) -> &mut ::protobuf::RepeatedField<Document> {
        &mut self.documents
    }

    // Take field
    pub fn take_documents(&mut self) -> ::protobuf::RepeatedField<Document> {
        ::std::mem::replace(&mut self.documents, ::protobuf::RepeatedField::new())
    }

    pub fn get_documents(&self) -> &[Document] {
        &self.documents
    }

    // repeated .contentkm.Media media_items = 2;

    pub fn clear_media_items(&mut self) {
        self.media_items.clear();
    }

    // Param is passed by value, moved
    pub fn set_media_items(&mut self, v: ::protobuf::RepeatedField<Media>) {
        self.media_items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_media_items(&mut self) -> &mut ::protobuf::RepeatedField<Media> {
        &mut self.media_items
    }

    // Take field
    pub fn take_media_items(&mut self) -> ::protobuf::RepeatedField<Media> {
        ::std::mem::replace(&mut self.media_items, ::protobuf::RepeatedField::new())
    }

    pub fn get_media_items(&self) -> &[Media] {
        &self.media_items
    }
}

impl ::protobuf::Message for Content {
    fn is_initialized(&self) -> bool {
        for v in &self.documents {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.media_items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.documents)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.media_items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.documents {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.media_items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.documents {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.media_items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Content {
        Content::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Document>>(
                    "documents",
                    |m: &Content| { &m.documents },
                    |m: &mut Content| { &mut m.documents },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Media>>(
                    "media_items",
                    |m: &Content| { &m.media_items },
                    |m: &mut Content| { &mut m.media_items },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Content>(
                    "Content",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Content {
        static mut instance: ::protobuf::lazy::Lazy<Content> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Content,
        };
        unsafe {
            instance.get(Content::new)
        }
    }
}

impl ::protobuf::Clear for Content {
    fn clear(&mut self) {
        self.clear_documents();
        self.clear_media_items();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Content {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Content {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContentHandles {
    // message fields
    pub document_ids: ::protobuf::RepeatedField<Identification>,
    pub message: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ContentHandles {
    pub fn new() -> ContentHandles {
        ::std::default::Default::default()
    }

    // repeated .contentkm.Identification document_ids = 1;

    pub fn clear_document_ids(&mut self) {
        self.document_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_document_ids(&mut self, v: ::protobuf::RepeatedField<Identification>) {
        self.document_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_document_ids(&mut self) -> &mut ::protobuf::RepeatedField<Identification> {
        &mut self.document_ids
    }

    // Take field
    pub fn take_document_ids(&mut self) -> ::protobuf::RepeatedField<Identification> {
        ::std::mem::replace(&mut self.document_ids, ::protobuf::RepeatedField::new())
    }

    pub fn get_document_ids(&self) -> &[Identification] {
        &self.document_ids
    }

    // string message = 2;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }

    pub fn get_message(&self) -> &str {
        &self.message
    }
}

impl ::protobuf::Message for ContentHandles {
    fn is_initialized(&self) -> bool {
        for v in &self.document_ids {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.document_ids)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.document_ids {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.document_ids {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContentHandles {
        ContentHandles::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Identification>>(
                    "document_ids",
                    |m: &ContentHandles| { &m.document_ids },
                    |m: &mut ContentHandles| { &mut m.document_ids },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    |m: &ContentHandles| { &m.message },
                    |m: &mut ContentHandles| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ContentHandles>(
                    "ContentHandles",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ContentHandles {
        static mut instance: ::protobuf::lazy::Lazy<ContentHandles> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ContentHandles,
        };
        unsafe {
            instance.get(ContentHandles::new)
        }
    }
}

impl ::protobuf::Clear for ContentHandles {
    fn clear(&mut self) {
        self.clear_document_ids();
        self.clear_message();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContentHandles {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContentHandles {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Document {
    // message fields
    pub title: ::std::string::String,
    pub slug: ::std::string::String,
    pub publish: bool,
    pub body: ::std::string::String,
    pub language: Document_Language,
    pub importance: Document_Importance,
    pub media_filter: Document_MediaFilter,
    pub metadata: ::protobuf::SingularPtrField<MetaData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Document {
    pub fn new() -> Document {
        ::std::default::Default::default()
    }

    // string title = 1;

    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        &mut self.title
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.title, ::std::string::String::new())
    }

    pub fn get_title(&self) -> &str {
        &self.title
    }

    // string slug = 2;

    pub fn clear_slug(&mut self) {
        self.slug.clear();
    }

    // Param is passed by value, moved
    pub fn set_slug(&mut self, v: ::std::string::String) {
        self.slug = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_slug(&mut self) -> &mut ::std::string::String {
        &mut self.slug
    }

    // Take field
    pub fn take_slug(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.slug, ::std::string::String::new())
    }

    pub fn get_slug(&self) -> &str {
        &self.slug
    }

    // bool publish = 3;

    pub fn clear_publish(&mut self) {
        self.publish = false;
    }

    // Param is passed by value, moved
    pub fn set_publish(&mut self, v: bool) {
        self.publish = v;
    }

    pub fn get_publish(&self) -> bool {
        self.publish
    }

    // string body = 4;

    pub fn clear_body(&mut self) {
        self.body.clear();
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: ::std::string::String) {
        self.body = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut ::std::string::String {
        &mut self.body
    }

    // Take field
    pub fn take_body(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.body, ::std::string::String::new())
    }

    pub fn get_body(&self) -> &str {
        &self.body
    }

    // .contentkm.Document.Language language = 5;

    pub fn clear_language(&mut self) {
        self.language = Document_Language::ENGLISH;
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: Document_Language) {
        self.language = v;
    }

    pub fn get_language(&self) -> Document_Language {
        self.language
    }

    // .contentkm.Document.Importance importance = 6;

    pub fn clear_importance(&mut self) {
        self.importance = Document_Importance::LOW;
    }

    // Param is passed by value, moved
    pub fn set_importance(&mut self, v: Document_Importance) {
        self.importance = v;
    }

    pub fn get_importance(&self) -> Document_Importance {
        self.importance
    }

    // .contentkm.Document.MediaFilter media_filter = 7;

    pub fn clear_media_filter(&mut self) {
        self.media_filter = Document_MediaFilter::IG_WILLOW;
    }

    // Param is passed by value, moved
    pub fn set_media_filter(&mut self, v: Document_MediaFilter) {
        self.media_filter = v;
    }

    pub fn get_media_filter(&self) -> Document_MediaFilter {
        self.media_filter
    }

    // .contentkm.MetaData metadata = 8;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: MetaData) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut MetaData {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> MetaData {
        self.metadata.take().unwrap_or_else(|| MetaData::new())
    }

    pub fn get_metadata(&self) -> &MetaData {
        self.metadata.as_ref().unwrap_or_else(|| MetaData::default_instance())
    }
}

impl ::protobuf::Message for Document {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.title)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.slug)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.publish = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.body)?;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.language, 5, &mut self.unknown_fields)?
                },
                6 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.importance, 6, &mut self.unknown_fields)?
                },
                7 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.media_filter, 7, &mut self.unknown_fields)?
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.title);
        }
        if !self.slug.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.slug);
        }
        if self.publish != false {
            my_size += 2;
        }
        if !self.body.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.body);
        }
        if self.language != Document_Language::ENGLISH {
            my_size += ::protobuf::rt::enum_size(5, self.language);
        }
        if self.importance != Document_Importance::LOW {
            my_size += ::protobuf::rt::enum_size(6, self.importance);
        }
        if self.media_filter != Document_MediaFilter::IG_WILLOW {
            my_size += ::protobuf::rt::enum_size(7, self.media_filter);
        }
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.title.is_empty() {
            os.write_string(1, &self.title)?;
        }
        if !self.slug.is_empty() {
            os.write_string(2, &self.slug)?;
        }
        if self.publish != false {
            os.write_bool(3, self.publish)?;
        }
        if !self.body.is_empty() {
            os.write_string(4, &self.body)?;
        }
        if self.language != Document_Language::ENGLISH {
            os.write_enum(5, self.language.value())?;
        }
        if self.importance != Document_Importance::LOW {
            os.write_enum(6, self.importance.value())?;
        }
        if self.media_filter != Document_MediaFilter::IG_WILLOW {
            os.write_enum(7, self.media_filter.value())?;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Document {
        Document::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "title",
                    |m: &Document| { &m.title },
                    |m: &mut Document| { &mut m.title },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "slug",
                    |m: &Document| { &m.slug },
                    |m: &mut Document| { &mut m.slug },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "publish",
                    |m: &Document| { &m.publish },
                    |m: &mut Document| { &mut m.publish },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "body",
                    |m: &Document| { &m.body },
                    |m: &mut Document| { &mut m.body },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Document_Language>>(
                    "language",
                    |m: &Document| { &m.language },
                    |m: &mut Document| { &mut m.language },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Document_Importance>>(
                    "importance",
                    |m: &Document| { &m.importance },
                    |m: &mut Document| { &mut m.importance },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Document_MediaFilter>>(
                    "media_filter",
                    |m: &Document| { &m.media_filter },
                    |m: &mut Document| { &mut m.media_filter },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MetaData>>(
                    "metadata",
                    |m: &Document| { &m.metadata },
                    |m: &mut Document| { &mut m.metadata },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Document>(
                    "Document",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Document {
        static mut instance: ::protobuf::lazy::Lazy<Document> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Document,
        };
        unsafe {
            instance.get(Document::new)
        }
    }
}

impl ::protobuf::Clear for Document {
    fn clear(&mut self) {
        self.clear_title();
        self.clear_slug();
        self.clear_publish();
        self.clear_body();
        self.clear_language();
        self.clear_importance();
        self.clear_media_filter();
        self.clear_metadata();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Document {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Document {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Document_Language {
    ENGLISH = 0,
    FRENCH = 1,
    PORTUGUESE = 2,
    SPANISH = 3,
    SWAHILI = 4,
}

impl ::protobuf::ProtobufEnum for Document_Language {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Document_Language> {
        match value {
            0 => ::std::option::Option::Some(Document_Language::ENGLISH),
            1 => ::std::option::Option::Some(Document_Language::FRENCH),
            2 => ::std::option::Option::Some(Document_Language::PORTUGUESE),
            3 => ::std::option::Option::Some(Document_Language::SPANISH),
            4 => ::std::option::Option::Some(Document_Language::SWAHILI),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Document_Language] = &[
            Document_Language::ENGLISH,
            Document_Language::FRENCH,
            Document_Language::PORTUGUESE,
            Document_Language::SPANISH,
            Document_Language::SWAHILI,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Document_Language", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Document_Language {
}

impl ::std::default::Default for Document_Language {
    fn default() -> Self {
        Document_Language::ENGLISH
    }
}

impl ::protobuf::reflect::ProtobufValue for Document_Language {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Document_Importance {
    LOW = 0,
    MEDIUM = 1,
    HIGH = 2,
    CRITICAL = 3,
}

impl ::protobuf::ProtobufEnum for Document_Importance {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Document_Importance> {
        match value {
            0 => ::std::option::Option::Some(Document_Importance::LOW),
            1 => ::std::option::Option::Some(Document_Importance::MEDIUM),
            2 => ::std::option::Option::Some(Document_Importance::HIGH),
            3 => ::std::option::Option::Some(Document_Importance::CRITICAL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Document_Importance] = &[
            Document_Importance::LOW,
            Document_Importance::MEDIUM,
            Document_Importance::HIGH,
            Document_Importance::CRITICAL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Document_Importance", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Document_Importance {
}

impl ::std::default::Default for Document_Importance {
    fn default() -> Self {
        Document_Importance::LOW
    }
}

impl ::protobuf::reflect::ProtobufValue for Document_Importance {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Document_MediaFilter {
    IG_WILLOW = 0,
    IG_WALDEN = 1,
    IG_VALENCIA = 2,
    IG_TOASTER = 3,
    IG_SUTRO = 4,
    IG_SIERRA = 5,
    IG_RISE = 6,
    IG_NASHVILLE = 7,
    IG_MAYFAIR = 8,
    IG_LOFI = 9,
    IG_KELVIN = 10,
    IG_INKWELL = 11,
    IG_HUDSON = 12,
    IG_HEFE = 13,
    IG_EARLYBIRD = 14,
    IG_BRANNAN = 15,
    IG_AMARO = 16,
    IG_1977 = 17,
}

impl ::protobuf::ProtobufEnum for Document_MediaFilter {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Document_MediaFilter> {
        match value {
            0 => ::std::option::Option::Some(Document_MediaFilter::IG_WILLOW),
            1 => ::std::option::Option::Some(Document_MediaFilter::IG_WALDEN),
            2 => ::std::option::Option::Some(Document_MediaFilter::IG_VALENCIA),
            3 => ::std::option::Option::Some(Document_MediaFilter::IG_TOASTER),
            4 => ::std::option::Option::Some(Document_MediaFilter::IG_SUTRO),
            5 => ::std::option::Option::Some(Document_MediaFilter::IG_SIERRA),
            6 => ::std::option::Option::Some(Document_MediaFilter::IG_RISE),
            7 => ::std::option::Option::Some(Document_MediaFilter::IG_NASHVILLE),
            8 => ::std::option::Option::Some(Document_MediaFilter::IG_MAYFAIR),
            9 => ::std::option::Option::Some(Document_MediaFilter::IG_LOFI),
            10 => ::std::option::Option::Some(Document_MediaFilter::IG_KELVIN),
            11 => ::std::option::Option::Some(Document_MediaFilter::IG_INKWELL),
            12 => ::std::option::Option::Some(Document_MediaFilter::IG_HUDSON),
            13 => ::std::option::Option::Some(Document_MediaFilter::IG_HEFE),
            14 => ::std::option::Option::Some(Document_MediaFilter::IG_EARLYBIRD),
            15 => ::std::option::Option::Some(Document_MediaFilter::IG_BRANNAN),
            16 => ::std::option::Option::Some(Document_MediaFilter::IG_AMARO),
            17 => ::std::option::Option::Some(Document_MediaFilter::IG_1977),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Document_MediaFilter] = &[
            Document_MediaFilter::IG_WILLOW,
            Document_MediaFilter::IG_WALDEN,
            Document_MediaFilter::IG_VALENCIA,
            Document_MediaFilter::IG_TOASTER,
            Document_MediaFilter::IG_SUTRO,
            Document_MediaFilter::IG_SIERRA,
            Document_MediaFilter::IG_RISE,
            Document_MediaFilter::IG_NASHVILLE,
            Document_MediaFilter::IG_MAYFAIR,
            Document_MediaFilter::IG_LOFI,
            Document_MediaFilter::IG_KELVIN,
            Document_MediaFilter::IG_INKWELL,
            Document_MediaFilter::IG_HUDSON,
            Document_MediaFilter::IG_HEFE,
            Document_MediaFilter::IG_EARLYBIRD,
            Document_MediaFilter::IG_BRANNAN,
            Document_MediaFilter::IG_AMARO,
            Document_MediaFilter::IG_1977,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Document_MediaFilter", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Document_MediaFilter {
}

impl ::std::default::Default for Document_MediaFilter {
    fn default() -> Self {
        Document_MediaFilter::IG_WILLOW
    }
}

impl ::protobuf::reflect::ProtobufValue for Document_MediaFilter {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Media {
    // message fields
    pub name: ::std::string::String,
    pub field_type: Media_Type,
    pub file_url: ::std::string::String,
    pub metadata: ::protobuf::SingularPtrField<MetaData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Media {
    pub fn new() -> Media {
        ::std::default::Default::default()
    }

    // string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        &self.name
    }

    // .contentkm.Media.Type type = 2;

    pub fn clear_field_type(&mut self) {
        self.field_type = Media_Type::AUDIO;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Media_Type) {
        self.field_type = v;
    }

    pub fn get_field_type(&self) -> Media_Type {
        self.field_type
    }

    // string file_url = 3;

    pub fn clear_file_url(&mut self) {
        self.file_url.clear();
    }

    // Param is passed by value, moved
    pub fn set_file_url(&mut self, v: ::std::string::String) {
        self.file_url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_url(&mut self) -> &mut ::std::string::String {
        &mut self.file_url
    }

    // Take field
    pub fn take_file_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.file_url, ::std::string::String::new())
    }

    pub fn get_file_url(&self) -> &str {
        &self.file_url
    }

    // .contentkm.MetaData metadata = 4;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: MetaData) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut MetaData {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> MetaData {
        self.metadata.take().unwrap_or_else(|| MetaData::new())
    }

    pub fn get_metadata(&self) -> &MetaData {
        self.metadata.as_ref().unwrap_or_else(|| MetaData::default_instance())
    }
}

impl ::protobuf::Message for Media {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.file_url)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.field_type != Media_Type::AUDIO {
            my_size += ::protobuf::rt::enum_size(2, self.field_type);
        }
        if !self.file_url.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.file_url);
        }
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.field_type != Media_Type::AUDIO {
            os.write_enum(2, self.field_type.value())?;
        }
        if !self.file_url.is_empty() {
            os.write_string(3, &self.file_url)?;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Media {
        Media::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Media| { &m.name },
                    |m: &mut Media| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Media_Type>>(
                    "type",
                    |m: &Media| { &m.field_type },
                    |m: &mut Media| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "file_url",
                    |m: &Media| { &m.file_url },
                    |m: &mut Media| { &mut m.file_url },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MetaData>>(
                    "metadata",
                    |m: &Media| { &m.metadata },
                    |m: &mut Media| { &mut m.metadata },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Media>(
                    "Media",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Media {
        static mut instance: ::protobuf::lazy::Lazy<Media> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Media,
        };
        unsafe {
            instance.get(Media::new)
        }
    }
}

impl ::protobuf::Clear for Media {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_field_type();
        self.clear_file_url();
        self.clear_metadata();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Media {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Media {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Media_Type {
    AUDIO = 0,
    DOCUMENT = 1,
    IMAGE = 2,
    VIDEO = 3,
}

impl ::protobuf::ProtobufEnum for Media_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Media_Type> {
        match value {
            0 => ::std::option::Option::Some(Media_Type::AUDIO),
            1 => ::std::option::Option::Some(Media_Type::DOCUMENT),
            2 => ::std::option::Option::Some(Media_Type::IMAGE),
            3 => ::std::option::Option::Some(Media_Type::VIDEO),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Media_Type] = &[
            Media_Type::AUDIO,
            Media_Type::DOCUMENT,
            Media_Type::IMAGE,
            Media_Type::VIDEO,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Media_Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Media_Type {
}

impl ::std::default::Default for Media_Type {
    fn default() -> Self {
        Media_Type::AUDIO
    }
}

impl ::protobuf::reflect::ProtobufValue for Media_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MetaData {
    // message fields
    pub identification: ::protobuf::SingularPtrField<Identification>,
    pub timestamps: ::protobuf::SingularPtrField<TimeStamps>,
    pub m: ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Any>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl MetaData {
    pub fn new() -> MetaData {
        ::std::default::Default::default()
    }

    // .contentkm.Identification identification = 1;

    pub fn clear_identification(&mut self) {
        self.identification.clear();
    }

    pub fn has_identification(&self) -> bool {
        self.identification.is_some()
    }

    // Param is passed by value, moved
    pub fn set_identification(&mut self, v: Identification) {
        self.identification = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identification(&mut self) -> &mut Identification {
        if self.identification.is_none() {
            self.identification.set_default();
        }
        self.identification.as_mut().unwrap()
    }

    // Take field
    pub fn take_identification(&mut self) -> Identification {
        self.identification.take().unwrap_or_else(|| Identification::new())
    }

    pub fn get_identification(&self) -> &Identification {
        self.identification.as_ref().unwrap_or_else(|| Identification::default_instance())
    }

    // .contentkm.TimeStamps timestamps = 2;

    pub fn clear_timestamps(&mut self) {
        self.timestamps.clear();
    }

    pub fn has_timestamps(&self) -> bool {
        self.timestamps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamps(&mut self, v: TimeStamps) {
        self.timestamps = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_timestamps(&mut self) -> &mut TimeStamps {
        if self.timestamps.is_none() {
            self.timestamps.set_default();
        }
        self.timestamps.as_mut().unwrap()
    }

    // Take field
    pub fn take_timestamps(&mut self) -> TimeStamps {
        self.timestamps.take().unwrap_or_else(|| TimeStamps::new())
    }

    pub fn get_timestamps(&self) -> &TimeStamps {
        self.timestamps.as_ref().unwrap_or_else(|| TimeStamps::default_instance())
    }

    // repeated .contentkm.MetaData.MEntry m = 3;

    pub fn clear_m(&mut self) {
        self.m.clear();
    }

    // Param is passed by value, moved
    pub fn set_m(&mut self, v: ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Any>) {
        self.m = v;
    }

    // Mutable pointer to the field.
    pub fn mut_m(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Any> {
        &mut self.m
    }

    // Take field
    pub fn take_m(&mut self) -> ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Any> {
        ::std::mem::replace(&mut self.m, ::std::collections::HashMap::new())
    }

    pub fn get_m(&self) -> &::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Any> {
        &self.m
    }
}

impl ::protobuf::Message for MetaData {
    fn is_initialized(&self) -> bool {
        for v in &self.identification {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.timestamps {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.identification)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.timestamps)?;
                },
                3 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(wire_type, is, &mut self.m)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.identification.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.timestamps.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(3, &self.m);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.identification.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.timestamps.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(3, &self.m, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MetaData {
        MetaData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Identification>>(
                    "identification",
                    |m: &MetaData| { &m.identification },
                    |m: &mut MetaData| { &mut m.identification },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TimeStamps>>(
                    "timestamps",
                    |m: &MetaData| { &m.timestamps },
                    |m: &mut MetaData| { &mut m.timestamps },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                    "m",
                    |m: &MetaData| { &m.m },
                    |m: &mut MetaData| { &mut m.m },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MetaData>(
                    "MetaData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MetaData {
        static mut instance: ::protobuf::lazy::Lazy<MetaData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MetaData,
        };
        unsafe {
            instance.get(MetaData::new)
        }
    }
}

impl ::protobuf::Clear for MetaData {
    fn clear(&mut self) {
        self.clear_identification();
        self.clear_timestamps();
        self.clear_m();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MetaData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MetaData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Identification {
    // message fields
    pub user_id: ::std::string::String,
    pub identifier: ::std::string::String,
    pub tags: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Identification {
    pub fn new() -> Identification {
        ::std::default::Default::default()
    }

    // string user_id = 1;

    pub fn clear_user_id(&mut self) {
        self.user_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: ::std::string::String) {
        self.user_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_id(&mut self) -> &mut ::std::string::String {
        &mut self.user_id
    }

    // Take field
    pub fn take_user_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.user_id, ::std::string::String::new())
    }

    pub fn get_user_id(&self) -> &str {
        &self.user_id
    }

    // string identifier = 2;

    pub fn clear_identifier(&mut self) {
        self.identifier.clear();
    }

    // Param is passed by value, moved
    pub fn set_identifier(&mut self, v: ::std::string::String) {
        self.identifier = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identifier(&mut self) -> &mut ::std::string::String {
        &mut self.identifier
    }

    // Take field
    pub fn take_identifier(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.identifier, ::std::string::String::new())
    }

    pub fn get_identifier(&self) -> &str {
        &self.identifier
    }

    // repeated string tags = 3;

    pub fn clear_tags(&mut self) {
        self.tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.tags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tags(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.tags
    }

    // Take field
    pub fn take_tags(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.tags, ::protobuf::RepeatedField::new())
    }

    pub fn get_tags(&self) -> &[::std::string::String] {
        &self.tags
    }
}

impl ::protobuf::Message for Identification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.user_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.identifier)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tags)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.user_id);
        }
        if !self.identifier.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.identifier);
        }
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.user_id.is_empty() {
            os.write_string(1, &self.user_id)?;
        }
        if !self.identifier.is_empty() {
            os.write_string(2, &self.identifier)?;
        }
        for v in &self.tags {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Identification {
        Identification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "user_id",
                    |m: &Identification| { &m.user_id },
                    |m: &mut Identification| { &mut m.user_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "identifier",
                    |m: &Identification| { &m.identifier },
                    |m: &mut Identification| { &mut m.identifier },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "tags",
                    |m: &Identification| { &m.tags },
                    |m: &mut Identification| { &mut m.tags },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Identification>(
                    "Identification",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Identification {
        static mut instance: ::protobuf::lazy::Lazy<Identification> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Identification,
        };
        unsafe {
            instance.get(Identification::new)
        }
    }
}

impl ::protobuf::Clear for Identification {
    fn clear(&mut self) {
        self.clear_user_id();
        self.clear_identifier();
        self.clear_tags();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Identification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Identification {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TimeStamps {
    // message fields
    pub created: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub updated: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TimeStamps {
    pub fn new() -> TimeStamps {
        ::std::default::Default::default()
    }

    // .google.protobuf.Timestamp created = 1;

    pub fn clear_created(&mut self) {
        self.created.clear();
    }

    pub fn has_created(&self) -> bool {
        self.created.is_some()
    }

    // Param is passed by value, moved
    pub fn set_created(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.created = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_created(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.created.is_none() {
            self.created.set_default();
        }
        self.created.as_mut().unwrap()
    }

    // Take field
    pub fn take_created(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.created.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    pub fn get_created(&self) -> &::protobuf::well_known_types::Timestamp {
        self.created.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }

    // .google.protobuf.Timestamp updated = 2;

    pub fn clear_updated(&mut self) {
        self.updated.clear();
    }

    pub fn has_updated(&self) -> bool {
        self.updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updated(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.updated = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_updated(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.updated.is_none() {
            self.updated.set_default();
        }
        self.updated.as_mut().unwrap()
    }

    // Take field
    pub fn take_updated(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.updated.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    pub fn get_updated(&self) -> &::protobuf::well_known_types::Timestamp {
        self.updated.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
}

impl ::protobuf::Message for TimeStamps {
    fn is_initialized(&self) -> bool {
        for v in &self.created {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.updated {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.created)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.updated)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.created.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.updated.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.created.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.updated.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TimeStamps {
        TimeStamps::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "created",
                    |m: &TimeStamps| { &m.created },
                    |m: &mut TimeStamps| { &mut m.created },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "updated",
                    |m: &TimeStamps| { &m.updated },
                    |m: &mut TimeStamps| { &mut m.updated },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TimeStamps>(
                    "TimeStamps",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TimeStamps {
        static mut instance: ::protobuf::lazy::Lazy<TimeStamps> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TimeStamps,
        };
        unsafe {
            instance.get(TimeStamps::new)
        }
    }
}

impl ::protobuf::Clear for TimeStamps {
    fn clear(&mut self) {
        self.clear_created();
        self.clear_updated();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TimeStamps {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimeStamps {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x13svc/contentkm.proto\x12\tcontentkm\x1a\x19google/protobuf/any.prot\
    o\x1a\x1fgoogle/protobuf/timestamp.proto\"o\n\x07Content\x121\n\tdocumen\
    ts\x18\x01\x20\x03(\x0b2\x13.contentkm.DocumentR\tdocuments\x121\n\x0bme\
    dia_items\x18\x02\x20\x03(\x0b2\x10.contentkm.MediaR\nmediaItems\"h\n\
    \x0eContentHandles\x12<\n\x0cdocument_ids\x18\x01\x20\x03(\x0b2\x19.cont\
    entkm.IdentificationR\x0bdocumentIds\x12\x18\n\x07message\x18\x02\x20\
    \x01(\tR\x07message\"\xfb\x05\n\x08Document\x12\x14\n\x05title\x18\x01\
    \x20\x01(\tR\x05title\x12\x12\n\x04slug\x18\x02\x20\x01(\tR\x04slug\x12\
    \x18\n\x07publish\x18\x03\x20\x01(\x08R\x07publish\x12\x12\n\x04body\x18\
    \x04\x20\x01(\tR\x04body\x128\n\x08language\x18\x05\x20\x01(\x0e2\x1c.co\
    ntentkm.Document.LanguageR\x08language\x12>\n\nimportance\x18\x06\x20\
    \x01(\x0e2\x1e.contentkm.Document.ImportanceR\nimportance\x12B\n\x0cmedi\
    a_filter\x18\x07\x20\x01(\x0e2\x1f.contentkm.Document.MediaFilterR\x0bme\
    diaFilter\x12/\n\x08metadata\x18\x08\x20\x01(\x0b2\x13.contentkm.MetaDat\
    aR\x08metadata\"M\n\x08Language\x12\x0b\n\x07ENGLISH\x10\0\x12\n\n\x06FR\
    ENCH\x10\x01\x12\x0e\n\nPORTUGUESE\x10\x02\x12\x0b\n\x07SPANISH\x10\x03\
    \x12\x0b\n\x07SWAHILI\x10\x04\"9\n\nImportance\x12\x07\n\x03LOW\x10\0\
    \x12\n\n\x06MEDIUM\x10\x01\x12\x08\n\x04HIGH\x10\x02\x12\x0c\n\x08CRITIC\
    AL\x10\x03\"\x9d\x02\n\x0bMediaFilter\x12\r\n\tIG_WILLOW\x10\0\x12\r\n\t\
    IG_WALDEN\x10\x01\x12\x0f\n\x0bIG_VALENCIA\x10\x02\x12\x0e\n\nIG_TOASTER\
    \x10\x03\x12\x0c\n\x08IG_SUTRO\x10\x04\x12\r\n\tIG_SIERRA\x10\x05\x12\
    \x0b\n\x07IG_RISE\x10\x06\x12\x10\n\x0cIG_NASHVILLE\x10\x07\x12\x0e\n\nI\
    G_MAYFAIR\x10\x08\x12\x0b\n\x07IG_LOFI\x10\t\x12\r\n\tIG_KELVIN\x10\n\
    \x12\x0e\n\nIG_INKWELL\x10\x0b\x12\r\n\tIG_HUDSON\x10\x0c\x12\x0b\n\x07I\
    G_HEFE\x10\r\x12\x10\n\x0cIG_EARLYBIRD\x10\x0e\x12\x0e\n\nIG_BRANNAN\x10\
    \x0f\x12\x0c\n\x08IG_AMARO\x10\x10\x12\x0b\n\x07IG_1977\x10\x11\"\xc9\
    \x01\n\x05Media\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12)\n\x04\
    type\x18\x02\x20\x01(\x0e2\x15.contentkm.Media.TypeR\x04type\x12\x19\n\
    \x08file_url\x18\x03\x20\x01(\tR\x07fileUrl\x12/\n\x08metadata\x18\x04\
    \x20\x01(\x0b2\x13.contentkm.MetaDataR\x08metadata\"5\n\x04Type\x12\t\n\
    \x05AUDIO\x10\0\x12\x0c\n\x08DOCUMENT\x10\x01\x12\t\n\x05IMAGE\x10\x02\
    \x12\t\n\x05VIDEO\x10\x03\"\xfa\x01\n\x08MetaData\x12A\n\x0eidentificati\
    on\x18\x01\x20\x01(\x0b2\x19.contentkm.IdentificationR\x0eidentification\
    \x125\n\ntimestamps\x18\x02\x20\x01(\x0b2\x15.contentkm.TimeStampsR\ntim\
    estamps\x12(\n\x01m\x18\x03\x20\x03(\x0b2\x1a.contentkm.MetaData.MEntryR\
    \x01m\x1aJ\n\x06MEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12*\
    \n\x05value\x18\x02\x20\x01(\x0b2\x14.google.protobuf.AnyR\x05value:\x02\
    8\x01\"]\n\x0eIdentification\x12\x17\n\x07user_id\x18\x01\x20\x01(\tR\
    \x06userId\x12\x1e\n\nidentifier\x18\x02\x20\x01(\tR\nidentifier\x12\x12\
    \n\x04tags\x18\x03\x20\x03(\tR\x04tags\"x\n\nTimeStamps\x124\n\x07create\
    d\x18\x01\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x07created\x124\n\
    \x07updated\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x07upda\
    ted2\x7f\n\x07AuthKam\x129\n\x06Create\x12\x12.contentkm.Content\x1a\x19\
    .contentkm.ContentHandles\"\0\x129\n\x06Update\x12\x12.contentkm.Content\
    \x1a\x19.contentkm.ContentHandles\"\0b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
