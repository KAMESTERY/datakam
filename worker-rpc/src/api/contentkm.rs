// This file is generated by rust-protobuf 2.1.2. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct Content {
    // message fields
    pub documents: ::protobuf::RepeatedField<Document>,
    pub media_items: ::protobuf::RepeatedField<Media>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Content {
    pub fn new() -> Content {
        ::std::default::Default::default()
    }

    // repeated .grpc.Document documents = 1;

    pub fn clear_documents(&mut self) {
        self.documents.clear();
    }

    // Param is passed by value, moved
    pub fn set_documents(&mut self, v: ::protobuf::RepeatedField<Document>) {
        self.documents = v;
    }

    // Mutable pointer to the field.
    pub fn mut_documents(&mut self) -> &mut ::protobuf::RepeatedField<Document> {
        &mut self.documents
    }

    // Take field
    pub fn take_documents(&mut self) -> ::protobuf::RepeatedField<Document> {
        ::std::mem::replace(&mut self.documents, ::protobuf::RepeatedField::new())
    }

    pub fn get_documents(&self) -> &[Document] {
        &self.documents
    }

    // repeated .grpc.Media media_items = 2;

    pub fn clear_media_items(&mut self) {
        self.media_items.clear();
    }

    // Param is passed by value, moved
    pub fn set_media_items(&mut self, v: ::protobuf::RepeatedField<Media>) {
        self.media_items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_media_items(&mut self) -> &mut ::protobuf::RepeatedField<Media> {
        &mut self.media_items
    }

    // Take field
    pub fn take_media_items(&mut self) -> ::protobuf::RepeatedField<Media> {
        ::std::mem::replace(&mut self.media_items, ::protobuf::RepeatedField::new())
    }

    pub fn get_media_items(&self) -> &[Media] {
        &self.media_items
    }
}

impl ::protobuf::Message for Content {
    fn is_initialized(&self) -> bool {
        for v in &self.documents {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.media_items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.documents)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.media_items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.documents {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.media_items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.documents {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.media_items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Content {
        Content::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Document>>(
                    "documents",
                    |m: &Content| { &m.documents },
                    |m: &mut Content| { &mut m.documents },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Media>>(
                    "media_items",
                    |m: &Content| { &m.media_items },
                    |m: &mut Content| { &mut m.media_items },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Content>(
                    "Content",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Content {
        static mut instance: ::protobuf::lazy::Lazy<Content> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Content,
        };
        unsafe {
            instance.get(Content::new)
        }
    }
}

impl ::protobuf::Clear for Content {
    fn clear(&mut self) {
        self.clear_documents();
        self.clear_media_items();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Content {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Content {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContentHandles {
    // message fields
    pub item_ids: ::protobuf::RepeatedField<Identification>,
    pub message: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ContentHandles {
    pub fn new() -> ContentHandles {
        ::std::default::Default::default()
    }

    // repeated .grpc.Identification item_ids = 1;

    pub fn clear_item_ids(&mut self) {
        self.item_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_item_ids(&mut self, v: ::protobuf::RepeatedField<Identification>) {
        self.item_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_item_ids(&mut self) -> &mut ::protobuf::RepeatedField<Identification> {
        &mut self.item_ids
    }

    // Take field
    pub fn take_item_ids(&mut self) -> ::protobuf::RepeatedField<Identification> {
        ::std::mem::replace(&mut self.item_ids, ::protobuf::RepeatedField::new())
    }

    pub fn get_item_ids(&self) -> &[Identification] {
        &self.item_ids
    }

    // string message = 2;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }

    pub fn get_message(&self) -> &str {
        &self.message
    }
}

impl ::protobuf::Message for ContentHandles {
    fn is_initialized(&self) -> bool {
        for v in &self.item_ids {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.item_ids)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.item_ids {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.item_ids {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContentHandles {
        ContentHandles::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Identification>>(
                    "item_ids",
                    |m: &ContentHandles| { &m.item_ids },
                    |m: &mut ContentHandles| { &mut m.item_ids },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    |m: &ContentHandles| { &m.message },
                    |m: &mut ContentHandles| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ContentHandles>(
                    "ContentHandles",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ContentHandles {
        static mut instance: ::protobuf::lazy::Lazy<ContentHandles> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ContentHandles,
        };
        unsafe {
            instance.get(ContentHandles::new)
        }
    }
}

impl ::protobuf::Clear for ContentHandles {
    fn clear(&mut self) {
        self.clear_item_ids();
        self.clear_message();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContentHandles {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContentHandles {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Document {
    // message fields
    pub title: ::std::string::String,
    pub slug: ::std::string::String,
    pub publish: bool,
    pub body: ::std::string::String,
    pub langue: Document_Langue,
    pub niveau: Document_Niveau,
    pub filtre_visuel: Document_FiltreVisuel,
    pub metadata: ::protobuf::SingularPtrField<MetaData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Document {
    pub fn new() -> Document {
        ::std::default::Default::default()
    }

    // string title = 1;

    pub fn clear_title(&mut self) {
        self.title.clear();
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        &mut self.title
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.title, ::std::string::String::new())
    }

    pub fn get_title(&self) -> &str {
        &self.title
    }

    // string slug = 2;

    pub fn clear_slug(&mut self) {
        self.slug.clear();
    }

    // Param is passed by value, moved
    pub fn set_slug(&mut self, v: ::std::string::String) {
        self.slug = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_slug(&mut self) -> &mut ::std::string::String {
        &mut self.slug
    }

    // Take field
    pub fn take_slug(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.slug, ::std::string::String::new())
    }

    pub fn get_slug(&self) -> &str {
        &self.slug
    }

    // bool publish = 3;

    pub fn clear_publish(&mut self) {
        self.publish = false;
    }

    // Param is passed by value, moved
    pub fn set_publish(&mut self, v: bool) {
        self.publish = v;
    }

    pub fn get_publish(&self) -> bool {
        self.publish
    }

    // string body = 4;

    pub fn clear_body(&mut self) {
        self.body.clear();
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: ::std::string::String) {
        self.body = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut ::std::string::String {
        &mut self.body
    }

    // Take field
    pub fn take_body(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.body, ::std::string::String::new())
    }

    pub fn get_body(&self) -> &str {
        &self.body
    }

    // .grpc.Document.Langue langue = 5;

    pub fn clear_langue(&mut self) {
        self.langue = Document_Langue::ENGLISH;
    }

    // Param is passed by value, moved
    pub fn set_langue(&mut self, v: Document_Langue) {
        self.langue = v;
    }

    pub fn get_langue(&self) -> Document_Langue {
        self.langue
    }

    // .grpc.Document.Niveau niveau = 6;

    pub fn clear_niveau(&mut self) {
        self.niveau = Document_Niveau::LOW;
    }

    // Param is passed by value, moved
    pub fn set_niveau(&mut self, v: Document_Niveau) {
        self.niveau = v;
    }

    pub fn get_niveau(&self) -> Document_Niveau {
        self.niveau
    }

    // .grpc.Document.FiltreVisuel filtre_visuel = 7;

    pub fn clear_filtre_visuel(&mut self) {
        self.filtre_visuel = Document_FiltreVisuel::IG_WILLOW;
    }

    // Param is passed by value, moved
    pub fn set_filtre_visuel(&mut self, v: Document_FiltreVisuel) {
        self.filtre_visuel = v;
    }

    pub fn get_filtre_visuel(&self) -> Document_FiltreVisuel {
        self.filtre_visuel
    }

    // .grpc.MetaData metadata = 8;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: MetaData) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut MetaData {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> MetaData {
        self.metadata.take().unwrap_or_else(|| MetaData::new())
    }

    pub fn get_metadata(&self) -> &MetaData {
        self.metadata.as_ref().unwrap_or_else(|| MetaData::default_instance())
    }
}

impl ::protobuf::Message for Document {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.title)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.slug)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.publish = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.body)?;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.langue, 5, &mut self.unknown_fields)?
                },
                6 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.niveau, 6, &mut self.unknown_fields)?
                },
                7 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.filtre_visuel, 7, &mut self.unknown_fields)?
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.title);
        }
        if !self.slug.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.slug);
        }
        if self.publish != false {
            my_size += 2;
        }
        if !self.body.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.body);
        }
        if self.langue != Document_Langue::ENGLISH {
            my_size += ::protobuf::rt::enum_size(5, self.langue);
        }
        if self.niveau != Document_Niveau::LOW {
            my_size += ::protobuf::rt::enum_size(6, self.niveau);
        }
        if self.filtre_visuel != Document_FiltreVisuel::IG_WILLOW {
            my_size += ::protobuf::rt::enum_size(7, self.filtre_visuel);
        }
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.title.is_empty() {
            os.write_string(1, &self.title)?;
        }
        if !self.slug.is_empty() {
            os.write_string(2, &self.slug)?;
        }
        if self.publish != false {
            os.write_bool(3, self.publish)?;
        }
        if !self.body.is_empty() {
            os.write_string(4, &self.body)?;
        }
        if self.langue != Document_Langue::ENGLISH {
            os.write_enum(5, self.langue.value())?;
        }
        if self.niveau != Document_Niveau::LOW {
            os.write_enum(6, self.niveau.value())?;
        }
        if self.filtre_visuel != Document_FiltreVisuel::IG_WILLOW {
            os.write_enum(7, self.filtre_visuel.value())?;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Document {
        Document::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "title",
                    |m: &Document| { &m.title },
                    |m: &mut Document| { &mut m.title },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "slug",
                    |m: &Document| { &m.slug },
                    |m: &mut Document| { &mut m.slug },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "publish",
                    |m: &Document| { &m.publish },
                    |m: &mut Document| { &mut m.publish },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "body",
                    |m: &Document| { &m.body },
                    |m: &mut Document| { &mut m.body },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Document_Langue>>(
                    "langue",
                    |m: &Document| { &m.langue },
                    |m: &mut Document| { &mut m.langue },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Document_Niveau>>(
                    "niveau",
                    |m: &Document| { &m.niveau },
                    |m: &mut Document| { &mut m.niveau },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Document_FiltreVisuel>>(
                    "filtre_visuel",
                    |m: &Document| { &m.filtre_visuel },
                    |m: &mut Document| { &mut m.filtre_visuel },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MetaData>>(
                    "metadata",
                    |m: &Document| { &m.metadata },
                    |m: &mut Document| { &mut m.metadata },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Document>(
                    "Document",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Document {
        static mut instance: ::protobuf::lazy::Lazy<Document> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Document,
        };
        unsafe {
            instance.get(Document::new)
        }
    }
}

impl ::protobuf::Clear for Document {
    fn clear(&mut self) {
        self.clear_title();
        self.clear_slug();
        self.clear_publish();
        self.clear_body();
        self.clear_langue();
        self.clear_niveau();
        self.clear_filtre_visuel();
        self.clear_metadata();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Document {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Document {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Document_Langue {
    ENGLISH = 0,
    FRENCH = 1,
    PORTUGUESE = 2,
    SPANISH = 3,
    SWAHILI = 4,
}

impl ::protobuf::ProtobufEnum for Document_Langue {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Document_Langue> {
        match value {
            0 => ::std::option::Option::Some(Document_Langue::ENGLISH),
            1 => ::std::option::Option::Some(Document_Langue::FRENCH),
            2 => ::std::option::Option::Some(Document_Langue::PORTUGUESE),
            3 => ::std::option::Option::Some(Document_Langue::SPANISH),
            4 => ::std::option::Option::Some(Document_Langue::SWAHILI),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Document_Langue] = &[
            Document_Langue::ENGLISH,
            Document_Langue::FRENCH,
            Document_Langue::PORTUGUESE,
            Document_Langue::SPANISH,
            Document_Langue::SWAHILI,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Document_Langue", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Document_Langue {
}

impl ::std::default::Default for Document_Langue {
    fn default() -> Self {
        Document_Langue::ENGLISH
    }
}

impl ::protobuf::reflect::ProtobufValue for Document_Langue {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Document_Niveau {
    LOW = 0,
    MEDIUM = 1,
    HIGH = 2,
    CRITICAL = 3,
}

impl ::protobuf::ProtobufEnum for Document_Niveau {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Document_Niveau> {
        match value {
            0 => ::std::option::Option::Some(Document_Niveau::LOW),
            1 => ::std::option::Option::Some(Document_Niveau::MEDIUM),
            2 => ::std::option::Option::Some(Document_Niveau::HIGH),
            3 => ::std::option::Option::Some(Document_Niveau::CRITICAL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Document_Niveau] = &[
            Document_Niveau::LOW,
            Document_Niveau::MEDIUM,
            Document_Niveau::HIGH,
            Document_Niveau::CRITICAL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Document_Niveau", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Document_Niveau {
}

impl ::std::default::Default for Document_Niveau {
    fn default() -> Self {
        Document_Niveau::LOW
    }
}

impl ::protobuf::reflect::ProtobufValue for Document_Niveau {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Document_FiltreVisuel {
    IG_WILLOW = 0,
    IG_WALDEN = 1,
    IG_VALENCIA = 2,
    IG_TOASTER = 3,
    IG_SUTRO = 4,
    IG_SIERRA = 5,
    IG_RISE = 6,
    IG_NASHVILLE = 7,
    IG_MAYFAIR = 8,
    IG_LOFI = 9,
    IG_KELVIN = 10,
    IG_INKWELL = 11,
    IG_HUDSON = 12,
    IG_HEFE = 13,
    IG_EARLYBIRD = 14,
    IG_BRANNAN = 15,
    IG_AMARO = 16,
    IG_1977 = 17,
}

impl ::protobuf::ProtobufEnum for Document_FiltreVisuel {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Document_FiltreVisuel> {
        match value {
            0 => ::std::option::Option::Some(Document_FiltreVisuel::IG_WILLOW),
            1 => ::std::option::Option::Some(Document_FiltreVisuel::IG_WALDEN),
            2 => ::std::option::Option::Some(Document_FiltreVisuel::IG_VALENCIA),
            3 => ::std::option::Option::Some(Document_FiltreVisuel::IG_TOASTER),
            4 => ::std::option::Option::Some(Document_FiltreVisuel::IG_SUTRO),
            5 => ::std::option::Option::Some(Document_FiltreVisuel::IG_SIERRA),
            6 => ::std::option::Option::Some(Document_FiltreVisuel::IG_RISE),
            7 => ::std::option::Option::Some(Document_FiltreVisuel::IG_NASHVILLE),
            8 => ::std::option::Option::Some(Document_FiltreVisuel::IG_MAYFAIR),
            9 => ::std::option::Option::Some(Document_FiltreVisuel::IG_LOFI),
            10 => ::std::option::Option::Some(Document_FiltreVisuel::IG_KELVIN),
            11 => ::std::option::Option::Some(Document_FiltreVisuel::IG_INKWELL),
            12 => ::std::option::Option::Some(Document_FiltreVisuel::IG_HUDSON),
            13 => ::std::option::Option::Some(Document_FiltreVisuel::IG_HEFE),
            14 => ::std::option::Option::Some(Document_FiltreVisuel::IG_EARLYBIRD),
            15 => ::std::option::Option::Some(Document_FiltreVisuel::IG_BRANNAN),
            16 => ::std::option::Option::Some(Document_FiltreVisuel::IG_AMARO),
            17 => ::std::option::Option::Some(Document_FiltreVisuel::IG_1977),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Document_FiltreVisuel] = &[
            Document_FiltreVisuel::IG_WILLOW,
            Document_FiltreVisuel::IG_WALDEN,
            Document_FiltreVisuel::IG_VALENCIA,
            Document_FiltreVisuel::IG_TOASTER,
            Document_FiltreVisuel::IG_SUTRO,
            Document_FiltreVisuel::IG_SIERRA,
            Document_FiltreVisuel::IG_RISE,
            Document_FiltreVisuel::IG_NASHVILLE,
            Document_FiltreVisuel::IG_MAYFAIR,
            Document_FiltreVisuel::IG_LOFI,
            Document_FiltreVisuel::IG_KELVIN,
            Document_FiltreVisuel::IG_INKWELL,
            Document_FiltreVisuel::IG_HUDSON,
            Document_FiltreVisuel::IG_HEFE,
            Document_FiltreVisuel::IG_EARLYBIRD,
            Document_FiltreVisuel::IG_BRANNAN,
            Document_FiltreVisuel::IG_AMARO,
            Document_FiltreVisuel::IG_1977,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Document_FiltreVisuel", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Document_FiltreVisuel {
}

impl ::std::default::Default for Document_FiltreVisuel {
    fn default() -> Self {
        Document_FiltreVisuel::IG_WILLOW
    }
}

impl ::protobuf::reflect::ProtobufValue for Document_FiltreVisuel {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Media {
    // message fields
    pub name: ::std::string::String,
    pub categorie: Media_Categorie,
    pub file_url: ::std::string::String,
    pub metadata: ::protobuf::SingularPtrField<MetaData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Media {
    pub fn new() -> Media {
        ::std::default::Default::default()
    }

    // string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        &self.name
    }

    // .grpc.Media.Categorie categorie = 2;

    pub fn clear_categorie(&mut self) {
        self.categorie = Media_Categorie::AUDIO;
    }

    // Param is passed by value, moved
    pub fn set_categorie(&mut self, v: Media_Categorie) {
        self.categorie = v;
    }

    pub fn get_categorie(&self) -> Media_Categorie {
        self.categorie
    }

    // string file_url = 3;

    pub fn clear_file_url(&mut self) {
        self.file_url.clear();
    }

    // Param is passed by value, moved
    pub fn set_file_url(&mut self, v: ::std::string::String) {
        self.file_url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_url(&mut self) -> &mut ::std::string::String {
        &mut self.file_url
    }

    // Take field
    pub fn take_file_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.file_url, ::std::string::String::new())
    }

    pub fn get_file_url(&self) -> &str {
        &self.file_url
    }

    // .grpc.MetaData metadata = 4;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: MetaData) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut MetaData {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> MetaData {
        self.metadata.take().unwrap_or_else(|| MetaData::new())
    }

    pub fn get_metadata(&self) -> &MetaData {
        self.metadata.as_ref().unwrap_or_else(|| MetaData::default_instance())
    }
}

impl ::protobuf::Message for Media {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.categorie, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.file_url)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.categorie != Media_Categorie::AUDIO {
            my_size += ::protobuf::rt::enum_size(2, self.categorie);
        }
        if !self.file_url.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.file_url);
        }
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.categorie != Media_Categorie::AUDIO {
            os.write_enum(2, self.categorie.value())?;
        }
        if !self.file_url.is_empty() {
            os.write_string(3, &self.file_url)?;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Media {
        Media::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Media| { &m.name },
                    |m: &mut Media| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Media_Categorie>>(
                    "categorie",
                    |m: &Media| { &m.categorie },
                    |m: &mut Media| { &mut m.categorie },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "file_url",
                    |m: &Media| { &m.file_url },
                    |m: &mut Media| { &mut m.file_url },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MetaData>>(
                    "metadata",
                    |m: &Media| { &m.metadata },
                    |m: &mut Media| { &mut m.metadata },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Media>(
                    "Media",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Media {
        static mut instance: ::protobuf::lazy::Lazy<Media> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Media,
        };
        unsafe {
            instance.get(Media::new)
        }
    }
}

impl ::protobuf::Clear for Media {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_categorie();
        self.clear_file_url();
        self.clear_metadata();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Media {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Media {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Media_Categorie {
    AUDIO = 0,
    DOCUMENT = 1,
    IMAGE = 2,
    VIDEO = 3,
}

impl ::protobuf::ProtobufEnum for Media_Categorie {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Media_Categorie> {
        match value {
            0 => ::std::option::Option::Some(Media_Categorie::AUDIO),
            1 => ::std::option::Option::Some(Media_Categorie::DOCUMENT),
            2 => ::std::option::Option::Some(Media_Categorie::IMAGE),
            3 => ::std::option::Option::Some(Media_Categorie::VIDEO),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Media_Categorie] = &[
            Media_Categorie::AUDIO,
            Media_Categorie::DOCUMENT,
            Media_Categorie::IMAGE,
            Media_Categorie::VIDEO,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Media_Categorie", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Media_Categorie {
}

impl ::std::default::Default for Media_Categorie {
    fn default() -> Self {
        Media_Categorie::AUDIO
    }
}

impl ::protobuf::reflect::ProtobufValue for Media_Categorie {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MetaData {
    // message fields
    pub identification: ::protobuf::SingularPtrField<Identification>,
    pub timestamps: ::protobuf::SingularPtrField<TimeStamps>,
    pub m: ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Any>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl MetaData {
    pub fn new() -> MetaData {
        ::std::default::Default::default()
    }

    // .grpc.Identification identification = 1;

    pub fn clear_identification(&mut self) {
        self.identification.clear();
    }

    pub fn has_identification(&self) -> bool {
        self.identification.is_some()
    }

    // Param is passed by value, moved
    pub fn set_identification(&mut self, v: Identification) {
        self.identification = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identification(&mut self) -> &mut Identification {
        if self.identification.is_none() {
            self.identification.set_default();
        }
        self.identification.as_mut().unwrap()
    }

    // Take field
    pub fn take_identification(&mut self) -> Identification {
        self.identification.take().unwrap_or_else(|| Identification::new())
    }

    pub fn get_identification(&self) -> &Identification {
        self.identification.as_ref().unwrap_or_else(|| Identification::default_instance())
    }

    // .grpc.TimeStamps timestamps = 2;

    pub fn clear_timestamps(&mut self) {
        self.timestamps.clear();
    }

    pub fn has_timestamps(&self) -> bool {
        self.timestamps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamps(&mut self, v: TimeStamps) {
        self.timestamps = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_timestamps(&mut self) -> &mut TimeStamps {
        if self.timestamps.is_none() {
            self.timestamps.set_default();
        }
        self.timestamps.as_mut().unwrap()
    }

    // Take field
    pub fn take_timestamps(&mut self) -> TimeStamps {
        self.timestamps.take().unwrap_or_else(|| TimeStamps::new())
    }

    pub fn get_timestamps(&self) -> &TimeStamps {
        self.timestamps.as_ref().unwrap_or_else(|| TimeStamps::default_instance())
    }

    // repeated .grpc.MetaData.MEntry m = 3;

    pub fn clear_m(&mut self) {
        self.m.clear();
    }

    // Param is passed by value, moved
    pub fn set_m(&mut self, v: ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Any>) {
        self.m = v;
    }

    // Mutable pointer to the field.
    pub fn mut_m(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Any> {
        &mut self.m
    }

    // Take field
    pub fn take_m(&mut self) -> ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Any> {
        ::std::mem::replace(&mut self.m, ::std::collections::HashMap::new())
    }

    pub fn get_m(&self) -> &::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Any> {
        &self.m
    }
}

impl ::protobuf::Message for MetaData {
    fn is_initialized(&self) -> bool {
        for v in &self.identification {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.timestamps {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.identification)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.timestamps)?;
                },
                3 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(wire_type, is, &mut self.m)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.identification.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.timestamps.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(3, &self.m);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.identification.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.timestamps.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(3, &self.m, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MetaData {
        MetaData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Identification>>(
                    "identification",
                    |m: &MetaData| { &m.identification },
                    |m: &mut MetaData| { &mut m.identification },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TimeStamps>>(
                    "timestamps",
                    |m: &MetaData| { &m.timestamps },
                    |m: &mut MetaData| { &mut m.timestamps },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                    "m",
                    |m: &MetaData| { &m.m },
                    |m: &mut MetaData| { &mut m.m },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MetaData>(
                    "MetaData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MetaData {
        static mut instance: ::protobuf::lazy::Lazy<MetaData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MetaData,
        };
        unsafe {
            instance.get(MetaData::new)
        }
    }
}

impl ::protobuf::Clear for MetaData {
    fn clear(&mut self) {
        self.clear_identification();
        self.clear_timestamps();
        self.clear_m();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MetaData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MetaData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Identification {
    // message fields
    pub user_id: ::std::string::String,
    pub identifier: ::std::string::String,
    pub tags: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Identification {
    pub fn new() -> Identification {
        ::std::default::Default::default()
    }

    // string user_id = 1;

    pub fn clear_user_id(&mut self) {
        self.user_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: ::std::string::String) {
        self.user_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_id(&mut self) -> &mut ::std::string::String {
        &mut self.user_id
    }

    // Take field
    pub fn take_user_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.user_id, ::std::string::String::new())
    }

    pub fn get_user_id(&self) -> &str {
        &self.user_id
    }

    // string identifier = 2;

    pub fn clear_identifier(&mut self) {
        self.identifier.clear();
    }

    // Param is passed by value, moved
    pub fn set_identifier(&mut self, v: ::std::string::String) {
        self.identifier = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identifier(&mut self) -> &mut ::std::string::String {
        &mut self.identifier
    }

    // Take field
    pub fn take_identifier(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.identifier, ::std::string::String::new())
    }

    pub fn get_identifier(&self) -> &str {
        &self.identifier
    }

    // repeated string tags = 3;

    pub fn clear_tags(&mut self) {
        self.tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.tags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tags(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.tags
    }

    // Take field
    pub fn take_tags(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.tags, ::protobuf::RepeatedField::new())
    }

    pub fn get_tags(&self) -> &[::std::string::String] {
        &self.tags
    }
}

impl ::protobuf::Message for Identification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.user_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.identifier)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tags)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.user_id);
        }
        if !self.identifier.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.identifier);
        }
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.user_id.is_empty() {
            os.write_string(1, &self.user_id)?;
        }
        if !self.identifier.is_empty() {
            os.write_string(2, &self.identifier)?;
        }
        for v in &self.tags {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Identification {
        Identification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "user_id",
                    |m: &Identification| { &m.user_id },
                    |m: &mut Identification| { &mut m.user_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "identifier",
                    |m: &Identification| { &m.identifier },
                    |m: &mut Identification| { &mut m.identifier },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "tags",
                    |m: &Identification| { &m.tags },
                    |m: &mut Identification| { &mut m.tags },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Identification>(
                    "Identification",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Identification {
        static mut instance: ::protobuf::lazy::Lazy<Identification> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Identification,
        };
        unsafe {
            instance.get(Identification::new)
        }
    }
}

impl ::protobuf::Clear for Identification {
    fn clear(&mut self) {
        self.clear_user_id();
        self.clear_identifier();
        self.clear_tags();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Identification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Identification {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TimeStamps {
    // message fields
    pub created: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub updated: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TimeStamps {
    pub fn new() -> TimeStamps {
        ::std::default::Default::default()
    }

    // .google.protobuf.Timestamp created = 1;

    pub fn clear_created(&mut self) {
        self.created.clear();
    }

    pub fn has_created(&self) -> bool {
        self.created.is_some()
    }

    // Param is passed by value, moved
    pub fn set_created(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.created = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_created(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.created.is_none() {
            self.created.set_default();
        }
        self.created.as_mut().unwrap()
    }

    // Take field
    pub fn take_created(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.created.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    pub fn get_created(&self) -> &::protobuf::well_known_types::Timestamp {
        self.created.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }

    // .google.protobuf.Timestamp updated = 2;

    pub fn clear_updated(&mut self) {
        self.updated.clear();
    }

    pub fn has_updated(&self) -> bool {
        self.updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updated(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.updated = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_updated(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.updated.is_none() {
            self.updated.set_default();
        }
        self.updated.as_mut().unwrap()
    }

    // Take field
    pub fn take_updated(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.updated.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    pub fn get_updated(&self) -> &::protobuf::well_known_types::Timestamp {
        self.updated.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
}

impl ::protobuf::Message for TimeStamps {
    fn is_initialized(&self) -> bool {
        for v in &self.created {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.updated {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.created)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.updated)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.created.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.updated.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.created.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.updated.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TimeStamps {
        TimeStamps::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "created",
                    |m: &TimeStamps| { &m.created },
                    |m: &mut TimeStamps| { &mut m.created },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "updated",
                    |m: &TimeStamps| { &m.updated },
                    |m: &mut TimeStamps| { &mut m.updated },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TimeStamps>(
                    "TimeStamps",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TimeStamps {
        static mut instance: ::protobuf::lazy::Lazy<TimeStamps> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TimeStamps,
        };
        unsafe {
            instance.get(TimeStamps::new)
        }
    }
}

impl ::protobuf::Clear for TimeStamps {
    fn clear(&mut self) {
        self.clear_created();
        self.clear_updated();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TimeStamps {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimeStamps {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x13svc/contentkm.proto\x12\x04grpc\x1a\x19google/protobuf/any.proto\
    \x1a\x1fgoogle/protobuf/timestamp.proto\"e\n\x07Content\x12,\n\tdocument\
    s\x18\x01\x20\x03(\x0b2\x0e.grpc.DocumentR\tdocuments\x12,\n\x0bmedia_it\
    ems\x18\x02\x20\x03(\x0b2\x0b.grpc.MediaR\nmediaItems\"[\n\x0eContentHan\
    dles\x12/\n\x08item_ids\x18\x01\x20\x03(\x0b2\x14.grpc.IdentificationR\
    \x07itemIds\x12\x18\n\x07message\x18\x02\x20\x01(\tR\x07message\"\xd3\
    \x05\n\x08Document\x12\x14\n\x05title\x18\x01\x20\x01(\tR\x05title\x12\
    \x12\n\x04slug\x18\x02\x20\x01(\tR\x04slug\x12\x18\n\x07publish\x18\x03\
    \x20\x01(\x08R\x07publish\x12\x12\n\x04body\x18\x04\x20\x01(\tR\x04body\
    \x12-\n\x06langue\x18\x05\x20\x01(\x0e2\x15.grpc.Document.LangueR\x06lan\
    gue\x12-\n\x06niveau\x18\x06\x20\x01(\x0e2\x15.grpc.Document.NiveauR\x06\
    niveau\x12@\n\rfiltre_visuel\x18\x07\x20\x01(\x0e2\x1b.grpc.Document.Fil\
    treVisuelR\x0cfiltreVisuel\x12*\n\x08metadata\x18\x08\x20\x01(\x0b2\x0e.\
    grpc.MetaDataR\x08metadata\"K\n\x06Langue\x12\x0b\n\x07ENGLISH\x10\0\x12\
    \n\n\x06FRENCH\x10\x01\x12\x0e\n\nPORTUGUESE\x10\x02\x12\x0b\n\x07SPANIS\
    H\x10\x03\x12\x0b\n\x07SWAHILI\x10\x04\"5\n\x06Niveau\x12\x07\n\x03LOW\
    \x10\0\x12\n\n\x06MEDIUM\x10\x01\x12\x08\n\x04HIGH\x10\x02\x12\x0c\n\x08\
    CRITICAL\x10\x03\"\x9e\x02\n\x0cFiltreVisuel\x12\r\n\tIG_WILLOW\x10\0\
    \x12\r\n\tIG_WALDEN\x10\x01\x12\x0f\n\x0bIG_VALENCIA\x10\x02\x12\x0e\n\n\
    IG_TOASTER\x10\x03\x12\x0c\n\x08IG_SUTRO\x10\x04\x12\r\n\tIG_SIERRA\x10\
    \x05\x12\x0b\n\x07IG_RISE\x10\x06\x12\x10\n\x0cIG_NASHVILLE\x10\x07\x12\
    \x0e\n\nIG_MAYFAIR\x10\x08\x12\x0b\n\x07IG_LOFI\x10\t\x12\r\n\tIG_KELVIN\
    \x10\n\x12\x0e\n\nIG_INKWELL\x10\x0b\x12\r\n\tIG_HUDSON\x10\x0c\x12\x0b\
    \n\x07IG_HEFE\x10\r\x12\x10\n\x0cIG_EARLYBIRD\x10\x0e\x12\x0e\n\nIG_BRAN\
    NAN\x10\x0f\x12\x0c\n\x08IG_AMARO\x10\x10\x12\x0b\n\x07IG_1977\x10\x11\"\
    \xd3\x01\n\x05Media\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x123\n\
    \tcategorie\x18\x02\x20\x01(\x0e2\x15.grpc.Media.CategorieR\tcategorie\
    \x12\x19\n\x08file_url\x18\x03\x20\x01(\tR\x07fileUrl\x12*\n\x08metadata\
    \x18\x04\x20\x01(\x0b2\x0e.grpc.MetaDataR\x08metadata\":\n\tCategorie\
    \x12\t\n\x05AUDIO\x10\0\x12\x0c\n\x08DOCUMENT\x10\x01\x12\t\n\x05IMAGE\
    \x10\x02\x12\t\n\x05VIDEO\x10\x03\"\xeb\x01\n\x08MetaData\x12<\n\x0eiden\
    tification\x18\x01\x20\x01(\x0b2\x14.grpc.IdentificationR\x0eidentificat\
    ion\x120\n\ntimestamps\x18\x02\x20\x01(\x0b2\x10.grpc.TimeStampsR\ntimes\
    tamps\x12#\n\x01m\x18\x03\x20\x03(\x0b2\x15.grpc.MetaData.MEntryR\x01m\
    \x1aJ\n\x06MEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12*\n\x05\
    value\x18\x02\x20\x01(\x0b2\x14.google.protobuf.AnyR\x05value:\x028\x01\
    \"]\n\x0eIdentification\x12\x17\n\x07user_id\x18\x01\x20\x01(\tR\x06user\
    Id\x12\x1e\n\nidentifier\x18\x02\x20\x01(\tR\nidentifier\x12\x12\n\x04ta\
    gs\x18\x03\x20\x03(\tR\x04tags\"x\n\nTimeStamps\x124\n\x07created\x18\
    \x01\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x07created\x124\n\x07u\
    pdated\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x07updated2\
    \xd4\x01\n\nContentKam\x12/\n\x06Create\x12\r.grpc.Content\x1a\x14.grpc.\
    ContentHandles\"\0\x12/\n\x06Update\x12\r.grpc.Content\x1a\x14.grpc.Cont\
    entHandles\"\0\x12,\n\x03Get\x12\x14.grpc.ContentHandles\x1a\r.grpc.Cont\
    ent\"\0\x126\n\x06Delete\x12\x14.grpc.ContentHandles\x1a\x14.grpc.Conten\
    tHandles\"\0b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
